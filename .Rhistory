names(RP.out[['37cV40c']])
H = RP.out[['37cV40c']]
head(H$pfp)
subset(H$pfp, two.sided < 0.05)
dim(subset(H$pfp, two.sided < 0.05))
dim(H)
dim(H$pfp)
DEGs = subset(H$pfp, two.sided < 0.05)
rownames(DEGs)
Hot = GetUpDown(subset(H$pfp, two.sided < pfpThresh))
pfp = subset(H$pfp, two.sided < pfpThresh)
rownames(pfp)
H$FC[rownames(pfp),]
Hot = GetUpDown(sig, colname='FC')
H = RP.out[['37cV40c']]
DEGs = subset(H$pfp, two.sided < 0.05)
sig = subset(H$pfp, two.sided < pfpThresh)
sig$FC = H$FC[rownames(pfp),]
Hot = GetUpDown(sig, colname='FC')
Hot
Hot$up
Hot$up$FC
head(Hot$up$FC)
head(Hot$up)
rownames(pfp)
rownames(sig)
rownames(Hot$up)
sig$entrez = META$cold$GeneID[match(rownames(sig), META$cold$Symbol)]
head(sig)
test = MapSymbolToEntrez(rownames(sig), lm=FALSE)
cbind(rownames(sig), sig$entrez, test)
sig$entrez = MapSymbolToEntrez(rownames(sig), lm=FALSE)
Hot = GetUpDown(sig, colname='FC')
Hot
source('R/init.R')
names(hitSigs)
hits
source('~/Box Sync/CFDR/cfdr/code/R/test/test_DataProc.R')
TestGetHitSigs()
source('R/init.R')
dim(interactome)
head(interactome)
n=load(DataDir('gold_standards/interactome.RData'))
n
dim(interactome)
dim(subset(interactome, !is.na(entrez)))
head(interactome)
source('~/Box Sync/CFDR/cfdr/code/R/test/test_DataProc.R')
source('R/init.R')
source('~/Box Sync/CFDR/cfdr/code/R/test/test_DataProc.R')
source('R/init.R')
source('~/Box Sync/CFDR/cfdr/code/R/test/test_DataProc.R')
TestGetGroupNamesFromSeeds()
seeds = list(a='bla', b='foo', c='bar')
groupNames = names(seeds)
names(groupNames) = groupNames
groupNames = as.list(groupNames)
groupNames
list(a='a',b='b',c='c')
stopifnot(groupNames==list(a='a',b='b',c='c'))
stopifnot(identical(groupNames,list(a='a',b='b',c='c')))
source('R/initR')
source('R/init.R')
+
source('~/Box Sync/CFDR/cfdr/code/R/test/test_DataProc.R')
source('R/init.R')
L = GetLincsAnnot()
head(L)
length(which(!is.na(L$pubchem)))
length(which(!is.na(L$chembl_id)))
length(which(!is.na(L$mesh_id)))
length(which(!is.na(L$drugbank_id)))
length(which(!is.na(L$chebi_id)))
length(which(!is.na(L$kegg_id)))
setwd('/Users/rhodos/Desktop/Research/LINCS/submission/dgc_predict')
source('R/init.R')
LsVars()
i=5
LsVars()
LsVars()
rm(list=LsVars())
LsVars()
i=5
LsVars()
debug(TestLsVars)
TestLsVars()
LsVars()
undebug(TestLsVars)
TestLsVars()
source('R/init.R')
source('~/Desktop/Research/LINCS/submission/dgc_predict/R/src/EvaluateTensor.R')
source('~/Desktop/Research/LINCS/submission/dgc_predict/R/test/test_EvaluateTensor.R')
source('R/init.R')
warnings()
source('~/Desktop/Research/LINCS/submission/dgc_predict/R/scripts/test_ensemble_models.R')
# Method 1: Simply estimate a global trade-off parameter, lambda
for(lambda in seq(0, 1, 0.05)){
print(lambda)
ens = lambda * tensors$cv$tensor + (1-lambda)*tensors$cv$dnpp
err1[lambda] = ComputePCT(tensors$meas, ens)
}
seq(0, 1, 0.01)
seq(0, 1, 0.05)
err1 = sapply(seq(0, 1, 0.05), function(lambda){print(lambda); ens = lambda * tensors$cv$tensor + (1-lambda)*tensors$cv$dnpp; ComputePCT(tensors$meas, ens)})
err1
plot(seq(0, 1, 0.05), err1)
pct1 = err1
err1 = sapply(seq(0, 1, 0.05), function(lambda){print(lambda); ens = lambda * tensors$cv$tensor + (1-lambda)*tensors$cv$dnpp; ComputeErrorRate(tensors$meas, ens)})
LocalEnsEstimate = function(T_knn, T_tensor, alpha=0.5){
# Get max number of cell types available per drug
nPerDrug = NumSigs(T_knn, 'drug')
Nc = max(nPerDrug)
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
ens = array(data=NaN, dims=dims(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(i in 1:dim(T_knn, 1)){
print(i)
f1 = nPerDrug[i] / Nc
for(k in 1:dim(T_knn, 3)){
if(!is.na(T_knn[i,1,k])){
f2 = nPerCell[k] / Nd
lambda_ik = (alpha * f1 + f2) / (alpha + 1)
ens[i,:,k] = lambda_ik * T_tensor[i,:,k] + (1-lambda_ik) * T_knn[i,:,k]
lambdas[cnt] = lambda_ik
cnt = cnt + 1
}
}
}
return(ens)
}
LocalEnsEstimate = function(T_knn, T_tensor, alpha=0.5){
# Get max number of cell types available per drug
nPerDrug = NumSigs(T_knn, 'drug')
Nc = max(nPerDrug)
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
ens = array(data=NaN, dims=dims(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(i in 1:dim(T_knn, 1)){
print(i)
f1 = nPerDrug[i] / Nc
for(k in 1:dim(T_knn, 3)){
if(!is.na(T_knn[i,1,k])){
f2 = nPerCell[k] / Nd
lambda_ik = (alpha * f1 + f2) / (alpha + 1)
ens[i,:,k] = lambda_ik * T_tensor[i,:,k] + (1-lambda_ik) * T_knn[i,:,k]
lambdas[cnt] = lambda_ik
cnt = cnt + 1
}
}
}
return(ens)
}
LocalEnsEstimate = function(T_knn, T_tensor, alpha=0.5){
# Get max number of cell types available per drug
nPerDrug = NumSigs(T_knn, 'drug')
Nc = max(nPerDrug)
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
ens = array(data=NaN, dims=dims(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(i in 1:dim(T_knn, 1)){
print(i)
f1 = nPerDrug[i] / Nc
for(k in 1:dim(T_knn, 3)){
if(!is.na(T_knn[i,1,k])){
f2 = nPerCell[k] / Nd
lambda_ik = (alpha * f1 + f2) / (alpha + 1)
ens[i,,k] = lambda_ik * T_tensor[i,,k] + (1-lambda_ik) * T_knn[i,,k]
lambdas[cnt] = lambda_ik
cnt = cnt + 1
}
}
}
return(ens)
}
LocalEnsEstimate = function(T_knn, T_tensor, alpha=0.5){
# Get max number of cell types available per drug
nPerDrug = NumSigs(T_knn, 'drug')
Nc = max(nPerDrug)
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
ens = array(data=NaN, dims=dims(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(i in 1:dim(T_knn, 1)){
print(i)
f1 = nPerDrug[i] / Nc
for(k in 1:dim(T_knn, 3)){
if(!is.na(T_knn[i,1,k])){
f2 = nPerCell[k] / Nd
lambda_ik = (alpha * f1 + f2) / (alpha + 1)
ens[i,,k] = lambda_ik * T_tensor[i,,k] + (1-lambda_ik) * T_knn[i,,k]
lambdas[cnt] = lambda_ik
cnt = cnt + 1
}
}
}
return(list(ens=ens, lambdas=lambdas))
}
out = LocalEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, alpha=0.5)
T_knn = tensors$cv$dnpp
dim(T_knn)
LocalEnsEstimate = function(T_knn, T_tensor, alpha=0.5){
# Get max number of cell types available per drug
nPerDrug = NumSigs(T_knn, 'drug')
Nc = max(nPerDrug)
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
ens = array(data=NaN, dims=dim(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(i in 1:dim(T_knn, 1)){
print(i)
f1 = nPerDrug[i] / Nc
for(k in 1:dim(T_knn, 3)){
if(!is.na(T_knn[i,1,k])){
f2 = nPerCell[k] / Nd
lambda_ik = (alpha * f1 + f2) / (alpha + 1)
ens[i,,k] = lambda_ik * T_tensor[i,,k] + (1-lambda_ik) * T_knn[i,,k]
lambdas[cnt] = lambda_ik
cnt = cnt + 1
}
}
}
return(list(ens=ens, lambdas=lambdas))
}
out = LocalEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, alpha=0.5)
LocalEnsEstimate = function(T_knn, T_tensor, alpha=0.5){
# Get max number of cell types available per drug
nPerDrug = NumSigs(T_knn, 'drug')
Nc = max(nPerDrug)
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
ens = array(data=NaN, dim=dim(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(i in 1:dim(T_knn, 1)){
print(i)
f1 = nPerDrug[i] / Nc
for(k in 1:dim(T_knn, 3)){
if(!is.na(T_knn[i,1,k])){
f2 = nPerCell[k] / Nd
lambda_ik = (alpha * f1 + f2) / (alpha + 1)
ens[i,,k] = lambda_ik * T_tensor[i,,k] + (1-lambda_ik) * T_knn[i,,k]
lambdas[cnt] = lambda_ik
cnt = cnt + 1
}
}
}
return(list(ens=ens, lambdas=lambdas))
}
out = LocalEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, alpha=0.5)
dim(T_knn)
dim(T_knn)[1]
LocalEnsEstimate = function(T_knn, T_tensor, alpha=0.5){
# Get max number of cell types available per drug
nPerDrug = NumSigs(T_knn, 'drug')
Nc = max(nPerDrug)
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
ens = array(data=NaN, dim=dim(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(i in 1:dim(T_knn)[1]){
print(i)
f1 = nPerDrug[i] / Nc
for(k in 1:dim(T_knn)[3]){
if(!is.na(T_knn[i,1,k])){
f2 = nPerCell[k] / Nd
lambda_ik = (alpha * f1 + f2) / (alpha + 1)
ens[i,,k] = lambda_ik * T_tensor[i,,k] + (1-lambda_ik) * T_knn[i,,k]
lambdas[cnt] = lambda_ik
cnt = cnt + 1
}
}
}
return(list(ens=ens, lambdas=lambdas))
}
out = LocalEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, alpha=0.5)
dim(out$ens)
out$ens
NumSigs(out$ens)
NumSigs(tensors$cv$dnpp)
ComputeErrorRate(out$ens, tensors$cv$dnpp)
ComputePCT(out$ens, tensors$cv$dnpp)
ComputeErrorRate(tensors$meas, out$ens)
ComputePCT(tensors$meas, out$ens)
hist(out$lambdas, breaks=1000)
hist(out$lambdas, breaks=100)
sm_tensors = list(dnpp=tensors$cv$dnpp[1:100,,1:10], tensor=tensors$cv$tensor[1:100,,1:10], meas=tensors$meas[1:100,,1:10])
sm_out = LocalEnsEstimate(sm_tensors$dnpp, sm_tensors$tensor, alpha=0.5)
hist(sm_out$lambdas)
sm = sm_tensors
test_local = sapply(seq(0, 1, 0.05), function(alpha){print(alpha); ens = LocalEnsEstimate(sm$dnpp, sm$tensor, alpha); ComputePCT(tensors$meas, out$ens)})
test_local = sapply(seq(0, 1, 0.05), function(alpha){print(alpha); tmp = LocalEnsEstimate(sm$dnpp, sm$tensor, alpha); ComputePCT(sm$meas, tmp$ens)})
test_local
alphas = seq(0, 1, 0.05)
plot(alphas, test_local)
#test_local = sapply(seq(0, 1, 0.05), function(alpha){print(alpha); tmp = LocalEnsEstimate(sm$dnpp, sm$tensor, alpha); ComputePCT(sm$meas, tmp$ens)})
i=1
tmp = list()
test_local = list()
for(alpha in alphas){
print(alpha)
tmp[[i]] = LocalEnsEstimate(sm$dnpp, sm$tensor, alpha)
test_local[[i]] = ComputePCT(sm$meas, tmp[[i]]$ens)
i = i+1
}
test_local
tmp[[1]]
nPerDrug = NumSigs(T_knn, 'drug')
nPerDrug
hist(nPerDrug)
LocalEnsEst_Drug = function(T_knn, T_tensor, alpha=0.5){
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
drugFracPerCell = nPerCell / Nd
ens = array(data=NaN, dim=dim(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(k in 1:dim(T_knn)[3]){
lambda_k = alpha * drugFracPerCell[k]
for(i in 1:dim(T_knn)[1]){
if(!is.na(T_knn[i,1,k])){
ens[i,,k] = lambda_k * T_tensor[i,,k] + (1-lambda_k) * T_knn[i,,k]
lambdas[cnt] = lambda_k
cnt = cnt + 1
}
}
}
return(list(ens=ens, lambdas=lambdas))
}
i=1
tmp = list()
test_local = list()
for(alpha in alphas){
print(alpha)
tmp[[i]] = LocalEnsEst_Drug(sm$dnpp, sm$tensor, alpha)
test_local[[i]] = ComputePCT(sm$meas, tmp[[i]]$ens)
i = i+1
}
test_local
plot(alphas, unlist(test_local), main='simpler heuristic using only drug counts')
pct2 = sapply(seq(0, 1, 0.05), function(alpha){print(alpha); tmp = LocalEnsEst_Drug(tensors$cv$dnpp, tensors$cv$tensor, alpha); ComputePCT(tensors$meas, tmp$ens)})
plot(alphas, unlist(pct2), main='simpler heuristic, full tensor')
pct1
dim(T_knn)
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
drugFracPerCell = nPerCell / Nd
ens = array(data=NaN, dim=dim(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(k in 1:dim(T_knn)[3]){
lambda_k = alpha * drugFracPerCell[k]
}
lambdas = sapply(1:dim(T_knn)[3], function(k)  alpha * drugFracPerCell[k])
lambdas
alpha
lambdas = lapply(alphas, function(alpha) sapply(1:dim(T_knn)[3], function(k)  alpha * drugFracPerCell[k]))
lambdas
alphas
dim(T_knn)
idx = c(1:50, 2081:2130)
length(idx)
sm = list(dnpp=tensors$cv$dnpp[idx,,1:10], tensor=tensors$cv$tensor[idx,,1:10], meas=tensors$meas[idx,,1:10])
LocalEnsEst_Drug = function(T_knn, T_tensor, alpha=0.5){
# Get max number of drugs available per cell type
nPerCell = NumSigs(T_knn, 'cell')
Nd = max(nPerCell)
drugFracPerCell = nPerCell / Nd
ens = array(data=NaN, dim=dim(T_knn), dimnames=dimnames(T_knn))
lambdas = c()
cnt = 1
for(k in 1:dim(T_knn)[3]){
lambda_k = alpha * drugFracPerCell[k]
for(i in 1:dim(T_knn)[1]){
if(!is.na(T_knn[i,1,k])){
ens[i,,k] = lambda_k * T_knn[i,,k] + (1-lambda_k) * T_tensor[i,,k]
lambdas[cnt] = lambda_k
cnt = cnt + 1
}
}
}
return(list(ens=ens, lambdas=lambdas))
}
sm_out = LocalEnsEstimate_Drug(sm_tensors$dnpp, sm_tensors$tensor, alpha=0.5)
sm_out = LocalEnsEst_Drug(sm_tensors$dnpp, sm_tensors$tensor, alpha=0.5)
sm_out
i=1
tmp = list()
test_local = list()
for(alpha in alphas){
print(alpha)
tmp[[i]] = LocalEnsEst_Drug(sm$dnpp, sm$tensor, alpha)
test_local[[i]] = ComputePCT(sm$meas, tmp[[i]]$ens)
i = i+1
}
plot(alphas, unlist(test_local), main='simpler heuristic using only drug counts')
sm = list(dnpp=tensors$cv$dnpp[1:100,,1:10], tensor=tensors$cv$tensor[1:100,,1:10], meas=tensors$meas[1:100,,1:10])
i=1
tmp = list()
test_local = list()
for(alpha in alphas){
print(alpha)
tmp[[i]] = LocalEnsEst_Drug(sm$dnpp, sm$tensor, alpha)
test_local[[i]] = ComputePCT(sm$meas, tmp[[i]]$ens)
i = i+1
}
main('sm_new')
plot(alphas, unlist(test_local), main='sm orig')
plot(alphas, unlist(pct2), main='simpler heuristic, full tensor')
plot(seq(0, 1, 0.05), pct1, main='global ensemble method')
sz
manycell = LoadTensorMat(DataDir('tensors/manycell.mat'))$tensor
dimnames(manycell)
HeuristicEnsEstimate = function(T_knn, T_tensor, manycell){
drugs = dimnames(manycell)[1]
cells = dimnames(manycell)[3]
ens = T_knn
for(drug in dimnames(T_knn)[1]){
for(cell in dimnames(T_knn)[3]){
if(drug %in% drugs && cell %in% cells){
ens[drug,,cell] = T_tensor[drug,,cell]
}
}
}
return(ens)
}
ens = HeuristicEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, manycell)
ComputePCT(tensors$meas, ens)
drugs
length(which(ens == tensors$cv$dnpp))
length(which(ens == tensors$cv$tensor))
drug
HeuristicEnsEstimate = function(T_knn, T_tensor, manycell){
drugs = dimnames(manycell)[1]
cells = dimnames(manycell)[3]
ens = T_knn
for(drug in dimnames(T_knn)[1]){
for(cell in dimnames(T_knn)[3]){
if(drug %in% drugs & cell %in% cells){
ens[drug,,cell] = T_tensor[drug,,cell]
}
}
}
return(ens)
}
ens = HeuristicEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, manycell)
debug(HeuristicEnsEstimate)
ens = HeuristicEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, manycell)
drugs
cells
length(drugs)
HeuristicEnsEstimate = function(T_knn, T_tensor, manycell){
drugs = dimnames(manycell)[[1]]
cells = dimnames(manycell)[[3]]
ens = T_knn
for(drug in dimnames(T_knn)[1]){
for(cell in dimnames(T_knn)[3]){
if(drug %in% drugs & cell %in% cells){
ens[drug,,cell] = T_tensor[drug,,cell]
}
}
}
return(ens)
}
debug(HeuristicEnsEstimate)
ens = HeuristicEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, manycell)
drugs
cells
length(drugs)
length(cells)
length(which(ens == tensors$cv$tensor))
drug
drug
HeuristicEnsEstimate = function(T_knn, T_tensor, manycell){
drugs = dimnames(manycell)[[1]]
cells = dimnames(manycell)[[3]]
ens = T_knn
for(drug in dimnames(T_knn)[[1]]){
for(cell in dimnames(T_knn)[[3]]){
if(drug %in% drugs & cell %in% cells){
ens[drug,,cell] = T_tensor[drug,,cell]
}
}
}
return(ens)
}
debug(HeuristicEnsEstimate)
ens = HeuristicEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, manycell)
undebug(HeuristicEnsEstimate)
ens = HeuristicEnsEstimate(tensors$cv$dnpp, tensors$cv$tensor, manycell)
length(which(ens == tensors$cv$tensor))
length(which(ens == tensosr$cv$dnpp))
length(which(ens == tensors$cv$dnpp))
5649906/9851394
ComputePCT(tensors$meas, ens)
