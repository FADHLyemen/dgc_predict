lincs.id=lincs.id[which.max(num.match)],
num.match=max(num.match))
#### Restrict both tensors to the drugs that map, and the common genes and cell lines
CMAP = CMAP[cmapNames %in% drugMap$cmap.name,,c('PC3', 'MCF7','HL60')]
LINCS = tensors$meas[pertIds %in% drugMap$lincs.id,genes,c('PC3', 'MCF7','HL60')]
# change the drugnames of CMAP to pertIds, and reorder according to LINCS ordering
dimnames(CMAP)[[1]] = drugMap$lincs.id[match(dimnames(CMAP)[[1]], drugMap$cmap.name)]
CMAP = CMAP[dimnames(LINCS)[[1]],,]
# Some drugs don't have data in any of the three cell types in LINCS, so restrict further
idxZero = which(NumSigs(LINCS,'drug')==0)
LINCS = LINCS[-idxZero,,]
CMAP = CMAP[-idxZero,,]
SubsetTensorBy <- function(LINCS, tensor){
return(tensor[dimnames(LINCS)[[1]], dimnames(LINCS)[[2]], dimnames(LINCS)[[3]]])
}
#### Finally, compute the correlations
C = lapply(tensors$cv, function(tensor) ComputePCTPerSig(CMAP, SubsetTensorBy(LINCS, tensor), format='df'))
names(C) = c('1D-Mean', '2D-Mean', 'KNN', 'Tensor')
C$True = ComputePCTPerSig(CMAP, LINCS, format='df')
C$True
C$True$adjP < 0.05
length(which(C$True$adjP < 0.05))
dim(C$True)
275/412
138/210
sig = C$True$adjP < 0.05 & C$True$R > 0
length(which(sig))
names(C)
for(method in names(C)){
C[[method]]$method = method
C[[method]]$sig = sig
}
length(sig)
C[['1D-Mean']]
length(sig)
LINCS_cv = SubsetTensorBy(LINCS, tensors$cv$mean)
NumSigs(LINCS_cv)
NumSigs(LINCS)
LINCS[is.na(LINCS_cv)] = NA
NumSigs(LINCS)
# extract cell and drug names
cells_long = as.character(sapply(colnames(PRL_entrez), function(x) unlist(strsplit(x,'_'))[1]))
drugs_long = as.character(sapply(colnames(PRL_entrez), function(x) unlist(strsplit(x,'_'))[2]))
genes_long = PRL_entrez[,1]
cells = unique(cells_long)
drugs = unique(drugs_long)
genes = as.character(GetLmGenes('entrez'))
genes = intersect(PRL_entrez[,1],genes)
nCells = length(cells)
nDrugs = length(drugs)
nGenes = length(genes)
nSigs = ncol(PRL_entrez)
CMAP = array(data=NA, dim=c(nDrugs,nGenes,nCells),
dimnames=list(drug=drugs, gene=genes, cell=cells))
for(k in 1:nSigs){
d = drugs_long[k]
g = intersect(PRL_entrez[,k],genes)
c = cells_long[k]
CMAP[d, g, c] = -RescaleVec(1:nGenes, a=-1, b=1, abs=FALSE)^5
}
cmapNames = drugs
#### Get meanP and nReps regarding large tensor sigs
load(DataDir('expr/tensor/tsize/large/tensor_stats.RData'))
#### Load mapping between LINCS and CMAP drugs
# Load mapping
load('/Users/rhodos/Desktop/Dropbox/Rachel/Thesis/drug_repurposing/data/lincs/mapping/pairwiseMap.RData')
drugMap = pairwiseMap
drugMap$num.match = sapply(Str2Vec(drugMap$matching.fields, split='[,]'), length)
pertIds = dimnames(tensors$meas)[[1]]
# Restrict the mapping to compounds that are in the tensor and the CMAP subset
drugMap = drugMap[which(drugMap$lincs.id %in% pertIds),]
drugMap = drugMap[which(drugMap$cmap.name %in% cmapNames),]
# Make sure the mapping is 1:1
drugMap = ddply(drugMap, 'lincs.id', summarise,
cmap.name=cmap.name[which.max(num.match)],
num.match=max(num.match))
drugMap = ddply(drugMap, 'cmap.name', summarise,
lincs.id=lincs.id[which.max(num.match)],
num.match=max(num.match))
#### Restrict both tensors to the drugs that map, and the common genes and cell lines
CMAP = CMAP[cmapNames %in% drugMap$cmap.name,,c('PC3', 'MCF7','HL60')]
LINCS = tensors$meas[pertIds %in% drugMap$lincs.id,genes,c('PC3', 'MCF7','HL60')]
# Set non cross-validated profiles in LINCS tensor to zero
LINCS_cv = SubsetTensorBy(LINCS, tensors$cv$mean)
LINCS[is.na(LINCS_cv)] = NA
# change the drugnames of CMAP to pertIds, and reorder according to LINCS ordering
dimnames(CMAP)[[1]] = drugMap$lincs.id[match(dimnames(CMAP)[[1]], drugMap$cmap.name)]
CMAP = CMAP[dimnames(LINCS)[[1]],,]
# Some drugs don't have data in any of the three cell types in LINCS, so restrict further
idxZero = which(NumSigs(LINCS,'drug')==0)
LINCS = LINCS[-idxZero,,]
CMAP = CMAP[-idxZero,,]
SubsetTensorBy <- function(LINCS, tensor){
return(tensor[dimnames(LINCS)[[1]], dimnames(LINCS)[[2]], dimnames(LINCS)[[3]]])
}
#### Finally, compute the correlations
C = lapply(tensors$cv, function(tensor) ComputePCTPerSig(CMAP, SubsetTensorBy(LINCS, tensor), format='df'))
names(C) = c('1D-Mean', '2D-Mean', 'KNN', 'Tensor')
C$True = ComputePCTPerSig(CMAP, LINCS, format='df')
sig = C$True$adjP < 0.05 & C$True$R > 0
for(method in names(C)){
C[[method]]$method = method
C[[method]]$sig = sig
}
OUTPUT$CMAP_COMPARISON$ALL = lapply(C, function(x) c(mean=mean(x$R), sd=sd(x$R)))
OUTPUT$CMAP_COMPARISON$SIG = lapply(C, function(x) c(mean=mean(x$R[sig]), sd=sd(x$R[sig])))
OUTPUT$CMAP_COMPARISON$num_higher$all = sapply(C, function(c) length(which(C$True$R - c$R < 0)))
OUTPUT$CMAP_COMPARISON$num_higher$sig = sapply(C, function(c) length(which(C$True$R[sig] - c$R[sig] < 0)))
allC = Reduce(rbind, C)
allC$group = 'all'
allC_sig = subset(allC, sig)
allC_sig$group = 'significant'
data = rbind(allC, allC_sig)
data$method = factor(data$method, levels=c('True', '1D-Mean', '2D-Mean', 'KNN', 'Tensor'), ordered = TRUE)
p = ggplot(data, aes(x=method, y=R, group=interaction(group,method), fill=group)) +
geom_boxplot() +
theme_bw() +
xlab('Method') +
ylab('Correlation per signature') +
#ggtitle('Correlation between CMAP (measured) and \nL1000 (measured or predicted) signatures') +
theme(text = element_text(size=28), legend.title = element_blank(),
legend.text=element_text(size=28), legend.position = c(0.85, 0.1)) +
scale_fill_brewer(palette='YlGnBu') +
ylim(c(-0.6,1))
tiff(PlotDir('CMAP_L1000_comparisons.tiff'), width=600, height=500)
print(p)
dev.off()
diff = lapply(C, function(c) t.test(C$True[sig,'R'], c[sig,'R'], paired=TRUE)$estimate)
pval = lapply(C, function(c) t.test(C$True[sig,'R'], c[sig,'R'], paired=TRUE)$p.value)
# Turns out that KNN is the only one you can't distinguish from the correlations with measured signatures
meanp = as.vector(meanP[dimnames(LINCS)[[1]], dimnames(LINCS)[[3]]])
AUCScatter(na.omit(as.numeric(C$True$R))[sig], na.omit(as.numeric(C$KNN$R))[sig], xlim=c(-1,1), ylim=c(-1,1),
color=na.omit(-log10(meanp))[sig], labels='')
diff = lapply(C, function(c) t.test(C$True[sig,'R'], c[sig,'R'], paired=TRUE)$estimate)
pval = lapply(C, function(c) t.test(C$True[sig,'R'], c[sig,'R'], paired=TRUE)$p.value)
diff
pval
meanp = as.vector(meanP[dimnames(LINCS)[[1]], dimnames(LINCS)[[3]]])
AUCScatter(na.omit(as.numeric(C$True$R))[sig], na.omit(as.numeric(C$KNN$R))[sig], xlim=c(-1,1), ylim=c(-1,1),
color=na.omit(-log10(meanp))[sig], labels='')
C$True$R
as.numeric(C$True$R)
na.omit(as.numeric(C$True$R))
na.omit(as.numeric(C$True$R))[sig]
meanp
dim(meanP)
which(is.na(LINCS_cv[,1,]))
idx1 = which(is.na(LINCS_cv[,1,]))
idx2 = which(is.na(meanP))
length(idx1)
length(idx2)
dim(meanP)
meanp = as.vector(meanP[dimnames(LINCS)[[1]], dimnames(LINCS)[[3]]])
meanp
dim(meanP)
dim(LINCS_cv)
### Now perform similar analysis to see if intrinsic (i.e. CV) benchmark distinguishes between these methods
C = lapply(tensors$cv, function(tensor) ComputePCTPerSig(LINCS, SubsetTensorBy(LINCS, tensor), format='df'))
names(C) = c('1D-Mean', '2D-Mean', 'KNN', 'Tensor')
for(method in names(C)){
C[[method]]$method = method
C[[method]]$sig = sig ## I am keeping the same sig as defined earlier
}
load('/Users/rhodos/Desktop/Dropbox/Rachel/Thesis/drug_repurposing/data/cmap/PRL_entrez_cmap_cell_specific.RData')
# extract cell and drug names
cells_long = as.character(sapply(colnames(PRL_entrez), function(x) unlist(strsplit(x,'_'))[1]))
drugs_long = as.character(sapply(colnames(PRL_entrez), function(x) unlist(strsplit(x,'_'))[2]))
genes_long = PRL_entrez[,1]
cells = unique(cells_long)
drugs = unique(drugs_long)
genes = as.character(GetLmGenes('entrez'))
genes = intersect(PRL_entrez[,1],genes)
nCells = length(cells)
nDrugs = length(drugs)
nGenes = length(genes)
nSigs = ncol(PRL_entrez)
CMAP = array(data=NA, dim=c(nDrugs,nGenes,nCells),
dimnames=list(drug=drugs, gene=genes, cell=cells))
for(k in 1:nSigs){
d = drugs_long[k]
g = intersect(PRL_entrez[,k],genes)
c = cells_long[k]
CMAP[d, g, c] = -RescaleVec(1:nGenes, a=-1, b=1, abs=FALSE)^5
}
cmapNames = drugs
#### Get meanP and nReps regarding large tensor sigs
load(DataDir('expr/tensor/tsize/large/tensor_stats.RData'))
#### Load mapping between LINCS and CMAP drugs
# Load mapping
load('/Users/rhodos/Desktop/Dropbox/Rachel/Thesis/drug_repurposing/data/lincs/mapping/pairwiseMap.RData')
drugMap = pairwiseMap
drugMap$num.match = sapply(Str2Vec(drugMap$matching.fields, split='[,]'), length)
pertIds = dimnames(tensors$meas)[[1]]
# Restrict the mapping to compounds that are in the tensor and the CMAP subset
drugMap = drugMap[which(drugMap$lincs.id %in% pertIds),]
drugMap = drugMap[which(drugMap$cmap.name %in% cmapNames),]
# Make sure the mapping is 1:1
drugMap = ddply(drugMap, 'lincs.id', summarise,
cmap.name=cmap.name[which.max(num.match)],
num.match=max(num.match))
drugMap = ddply(drugMap, 'cmap.name', summarise,
lincs.id=lincs.id[which.max(num.match)],
num.match=max(num.match))
#### Restrict both tensors to the drugs that map, and the common genes and cell lines
CMAP = CMAP[cmapNames %in% drugMap$cmap.name,,c('PC3', 'MCF7','HL60')]
LINCS = tensors$meas[pertIds %in% drugMap$lincs.id,genes,c('PC3', 'MCF7','HL60')]
# Set non cross-validated profiles in LINCS tensor to zero
LINCS_cv = SubsetTensorBy(LINCS, tensors$cv$mean)
LINCS[is.na(LINCS_cv)] = NA
# change the drugnames of CMAP to pertIds, and reorder according to LINCS ordering
dimnames(CMAP)[[1]] = drugMap$lincs.id[match(dimnames(CMAP)[[1]], drugMap$cmap.name)]
CMAP = CMAP[dimnames(LINCS)[[1]],,]
# Some drugs don't have data in any of the three cell types in LINCS, so restrict further
idxZero = which(NumSigs(LINCS,'drug')==0)
LINCS = LINCS[-idxZero,,]
CMAP = CMAP[-idxZero,,]
SubsetTensorBy <- function(LINCS, tensor){
return(tensor[dimnames(LINCS)[[1]], dimnames(LINCS)[[2]], dimnames(LINCS)[[3]]])
}
#### Finally, compute the correlations
C = lapply(tensors$cv, function(tensor) ComputePCTPerSig(CMAP, SubsetTensorBy(LINCS, tensor), format='df'))
names(C) = c('1D-Mean', '2D-Mean', 'KNN', 'Tensor')
C$True = ComputePCTPerSig(CMAP, LINCS, format='df')
sig = C$True$adjP < 0.05 & C$True$R > 0
for(method in names(C)){
C[[method]]$method = method
C[[method]]$sig = sig
}
OUTPUT$CMAP_COMPARISON$ALL = lapply(C, function(x) c(mean=mean(x$R), sd=sd(x$R)))
OUTPUT$CMAP_COMPARISON$SIG = lapply(C, function(x) c(mean=mean(x$R[sig]), sd=sd(x$R[sig])))
OUTPUT$CMAP_COMPARISON$num_higher$all = sapply(C, function(c) length(which(C$True$R - c$R < 0)))
OUTPUT$CMAP_COMPARISON$num_higher$sig = sapply(C, function(c) length(which(C$True$R[sig] - c$R[sig] < 0)))
allC = Reduce(rbind, C)
allC$group = 'all'
allC_sig = subset(allC, sig)
allC_sig$group = 'significant'
data = rbind(allC, allC_sig)
data$method = factor(data$method, levels=c('True', '1D-Mean', '2D-Mean', 'KNN', 'Tensor'), ordered = TRUE)
p = ggplot(data, aes(x=method, y=R, group=interaction(group,method), fill=group)) +
geom_boxplot() +
theme_bw() +
xlab('Method') +
ylab('Correlation per signature') +
#ggtitle('Correlation between CMAP (measured) and \nL1000 (measured or predicted) signatures') +
theme(text = element_text(size=28), legend.title = element_blank(),
legend.text=element_text(size=28), legend.position = c(0.85, 0.1)) +
scale_fill_brewer(palette='YlGnBu') +
ylim(c(-0.6,1))
tiff(PlotDir('CMAP_L1000_comparisons.tiff'), width=600, height=500)
print(p)
dev.off()
diff = lapply(C, function(c) t.test(C$True[sig,'R'], c[sig,'R'], paired=TRUE)$estimate)
pval = lapply(C, function(c) t.test(C$True[sig,'R'], c[sig,'R'], paired=TRUE)$p.value)
# Turns out that KNN is the only one you can't distinguish from the correlations with measured signatures
# meanp = as.vector(meanP[dimnames(LINCS)[[1]], dimnames(LINCS)[[3]]])
# AUCScatter(na.omit(as.numeric(C$True$R))[sig], na.omit(as.numeric(C$KNN$R))[sig], xlim=c(-1,1), ylim=c(-1,1),
#            color=na.omit(-log10(meanp))[sig], labels='')
### Now perform similar analysis to see if intrinsic (i.e. CV) benchmark distinguishes between these methods
C = lapply(tensors$cv, function(tensor) ComputePCTPerSig(LINCS, SubsetTensorBy(LINCS, tensor), format='df'))
names(C) = c('1D-Mean', '2D-Mean', 'KNN', 'Tensor')
for(method in names(C)){
C[[method]]$method = method
C[[method]]$sig = sig ## I am keeping the same sig as defined earlier
}
### Now perform similar analysis to see if intrinsic (i.e. CV) benchmark distinguishes between these methods
C = lapply(tensors$cv, function(tensor) ComputePCTPerSig(LINCS, SubsetTensorBy(LINCS, tensor), format='df'))
names(C) = c('1D-Mean', '2D-Mean', 'KNN', 'Tensor')
for(method in names(C)){
C[[method]]$method = method
C[[method]]$sig = sig ## I am keeping the same sig as defined earlier
}
SubsetTensorBy <- function(LINCS, tensor, na.rm=FALSE){
out = tensor[dimnames(LINCS)[[1]], dimnames(LINCS)[[2]], dimnames(LINCS)[[3]]]
if(na.rm){
out[is.na(LINCS)] = NA
}
return(out)
}
source('~/Dropbox (Dudley Lab)/LINCS/code/lincs/R/dataprocessing/load_CMAP_PRLs_into_tensor.R')
identical(is.na(tensors$meas), is.na(tensors$cv$mean))
idx1 = which(is.na(tensors$meas)); idx2 = which(is.na(tensors$cv$mean)))
length(idx1)
idx2 = which(is.na(tensors$cv$mean))
length(idx2)
length(idx2) - length(idx1)
NumSigs(tensors$cv$mean)
NumSigs(tensors$meas)
source('~/Dropbox (Dudley Lab)/LINCS/code/lincs/R/cmap_compare/compare_cmap_lincs_PRL.R')
diff = lapply(C, function(c) t.test(C$True[sig,'R'], c[sig,'R'], paired=TRUE)$estimate)
pval = lapply(C, function(c) t.test(C$True[sig,'R'], c[sig,'R'], paired=TRUE)$p.value)
### Now perform similar analysis to see if intrinsic (i.e. CV) benchmark distinguishes between these methods
C = lapply(tensors$cv, function(tensor) ComputePCTPerSig(LINCS, SubsetTensorBy(LINCS, tensor), format='df'))
names(C) = c('1D-Mean', '2D-Mean', 'KNN', 'Tensor')
for(method in names(C)){
C[[method]]$method = method
C[[method]]$sig = sig ## I am keeping the same sig as defined earlier
}
NumSigs(tensors$meas)
NumSigs(tensors$cv$mean)
NumSigs(LINCS)
sig
length(sig)
rm(sig)
source('~/Dropbox (Dudley Lab)/LINCS/code/lincs/R/cmap_compare/compare_cmap_lincs_PRL.R')
C$True
NumSigs(tensors$cv$mean)
NumSigs(tensors$cv$mean2)
NumSigs(tensors$cv$knn)
NumSigs(tensors$cv$tensor)
C = lapply(tensors$cv, function(tensor) ComputePCTPerSig(CMAP, SubsetTensorBy(LINCS, tensor), format='df'))
names(C) = c('1D-Mean', '2D-Mean', 'KNN', 'Tensor')
C$True = ComputePCTPerSig(CMAP, LINCS, format='df')
dim(C$True)
NumSigs(LINCS)
rm(C)
C = lapply(tensors$cv, function(tensor) ComputePCTPerSig(CMAP, SubsetTensorBy(LINCS, tensor), format='df'))
names(C) = c('1D-Mean', '2D-Mean', 'KNN', 'Tensor')
C$True = ComputePCTPerSig(CMAP, LINCS, format='df')
sig = C$True$adjP < 0.05 & C$True$R > 0
for(method in names(C)){
C[[method]]$method = method
C[[method]]$sig = sig
}
dim(C$True)
C
testAll = TRUE
getwd()
rm(list=LsVars()); source('R/init.R')
rm(list=ls())
getwd()
setwd('../dgc_predict')
getwd()
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
source('R/init.R')
getwd()
source('R/init.R')
source('R/init.R')
library(rhdf5)
# Read all tensor data from large tensor experiments
tensors = list()
tsize = 'large'
print('loading data tensor..')
tensors$meas = LoadTensorMat(DataDir(sprintf('expr/tensor/tsize/%s/%s.mat', tsize, tsize)))$tensor
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/scripts/load_all_tensors_choose_size.R')
print('loading cross-validated tensors..')
file = ResultsDir(sprintf('%s_tensor_results.mat', tsize))
tensors$cv = list(mean=h5read(file, '#refs#/b'), mean2=h5read(file,'#refs#/c'),
knn=h5read(file,'#refs#/d'), tensor=h5read(file,'#refs#/e'))
print('loading cross-validated tensors..')
file = ResultsDir(sprintf('%s/%s_tensor_results.mat', tsize, tsize))
tensors$cv = list(mean=h5read(file, '#refs#/b'), mean2=h5read(file,'#refs#/c'),
knn=h5read(file,'#refs#/d'), tensor=h5read(file,'#refs#/e'))
tensors$cv = lapply(tensors$cv, function(tensor){dimnames(tensor) = dimnames(tensors$meas); return(tensor)})
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_6B-D_entity_specific_accuracy.R')
dev.off()
xm = c('knn','KNN')
color = list(drug = NumSigs(tensors$meas, dim='drug'),
gene = apply(abs(meanG), 1, function(x) max(x, na.rm=TRUE)),
cell = NumSigs(tensors$meas, dim='cell'))
leg = list(drug='# cells measured',gene = 'max gene-gene cor', cell = '# drugs measured')
cLim = list(drug = c('yellowgreen','red'),gene = c('red', 'blue'),cell = c('yellowgreen','red'))
palette = list(drug='RdYlGn', gene='RdYlBu', cell='RdYlGn')
size = list(drug=0.5, gene=0.5, cell=1)
alpha = list(drug=0.6, gene=0.9, cell=0.9)
circle = list()
labels = list(drug=annot$pertName, gene='', cell=annot$cellIds)
labels$drug[labels$drug=='HY-11007'] = 'GNF-2'
labels$drug[labels$drug=='M-3M3FBS'] = 'M3'
labelSize = list(drug=8, gene=8, cell=8)
labelRange = list(drug="name %in% c('homoharringtonine', 'terfenadine','dexamethasone', 'JNJ-38877605','M3','GNF-2')",
#y-x > 0.15 | x - y > 0.25 | y > 0.8 | y < 0 |
gene='y > 1',
cell="name %in% c('HUH7','NCIH508','SNUC5','HEK293T')")
dodge = list(drug=0, gene=-5, cell=0.1)
xLims = list(drug=range(C[[xm[1]]]$drug, C$tensor$drug, 1, -0.15),
gene=range(C[[xm[1]]]$gene, C$tensor$gene),
cell= range(C[[xm[1]]]$cell, C$tensor$cell))
yLims=xLims
for(dim in c('drug', 'gene', 'cell')){
f = substring(dim, 1, 1)
xlab = bquote('KNN PCT'[.(f)])
ylab = bquote('Tensor PCT'[.(f)])
x = rev(C[[xm[1]]][[dim]])
y = rev(C$tensor[[dim]])
AUCScatter(x, y, main=sprintf('%s-specific accuracy', capitalize(dim)),
color=rev(color[[dim]]), palette=palette[[dim]],
xlim=xLims[[dim]], ylim=yLims[[dim]],
labels=rev(labels[[dim]]), labelSize=labelSize[[dim]],
labelRange=labelRange[[dim]],dodge=dodge[[dim]],
xlab=xlab, ylab=ylab, alpha=alpha[[dim]],
circle=circle[[dim]], cLim = cLim[[dim]], size=size[[dim]],
legend.position=c(1,0), legend.title=leg[[dim]],
filename=sprintf('%s_specific_PCT_%s.tiff', dim, xm[2]))
}
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_1_L1000_cell_spec.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/src/DataProc.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_1_L1000_cell_spec.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_1_L1000_cell_spec.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_3A_scatter.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_3B_DEG_ROC.R')
tiff(PlotDir('ROC_tensor_knn_mean_mean2.tiff'), width=510, height=510)
lwd=5
lty = c(1, 3)
legend_str = c()
par(mar=c(5,6,4,2))
n_roc = 200
roc = list()
for(i in 1:length(percDEG)){
for(method in methods){
roc[[method]] = SubsetRoc(out[[method]][[i]]$roc, n_roc)
}
lt = lty[i]
if(i == 1){
plot(roc[['mean']]$fpr, roc[['mean']]$tpr, xlab='FPR', ylab='TPR', type='l', col=colors$mean,
lwd=lwd, ylim=c(0,1), cex.lab=2.0, cex.axis=1.5, lty=lt)
}else if(i > 1){
lines(roc[['mean']]$fpr, roc[['mean']]$tpr, col=colors$mean, lwd=lwd, type='l', lty=lt)
}
lines(roc[['mean2']]$fpr, roc[['mean2']]$tpr, col=colors$mean2, lwd=lwd, type='l', lty=lt)
lines(roc[['knn']]$fpr, roc[['knn']]$tpr, col=colors$knn, lwd=lwd, type='l', lty=lt)
lines(roc[['tensor']]$fpr, roc[['tensor']]$tpr, col=colors$tensor, lwd=lwd, type='l',lty=lt)
legend_str = c(legend_str, sprintf('Tensor, %0.0f%% DEG, AUC=%0.2f', percDEG[i], out[['tensor']][[i]]$auc))
legend_str = c(legend_str, sprintf('KNN, %0.0f%% DEG, AUC=%0.2f', percDEG[i], out[['knn']][[i]]$auc))
legend_str = c(legend_str, sprintf('2D-Mean, %0.0f%% DEG, AUC=%0.2f', percDEG[i], out[['mean2']][[i]]$auc))
legend_str = c(legend_str, sprintf('1D-Mean, %0.0f%% DEG, AUC=%0.2f', percDEG[i], out[['mean']][[i]]$auc))
}
lines(c(0,1), c(0,1), lwd=2, col='black', lty=3)
all_colors = unlist(c(rep(c(colors$tensor, colors$knn, colors$mean2, colors$mean), 2), 'black'))
legend('bottomright', lwd=4, legend=c(legend_str, 'random'),
col=all_colors, lty=c(1, 1, 1, 1, 3, 3, 3, 3, 3), cex=1.28)
dev.off()
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_3C_compare_cmap.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_3C_compare_cmap.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_3C_compare_cmap.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_4AB_cell_specific_drugs.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/src/Plot.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/src/Plot.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_4AB_cell_specific_drugs.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_1_L1000_cell_spec.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_5A_gene_cor_heatmaps.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_5A_gene_cor_heatmaps.R')
print('loading completed tensors and then generate merged and predicted tensors...')
for(method in c('mean', 'mean2','knn', 'tensor')){
print(method)
print('..completed tensor')
if(tsize == 'large'){
tcomp = h5read(DataDir(sprintf('results/tsize/large/hdf5/%s_final_hdf5.mat', method)),'T')
}else{
tcomp = LoadTensorMat(DataDir(sprintf('results/tsize/%s/%s_final.mat', tsize, method)))$tensor
}
dimnames(tcomp) = dimnames(tensors$meas)
tcomp = NormSigs(tcomp)
print('..merged tensor')
mergeT = tensors$cv[[method]]
mergeT[is.na(mergeT)] = tcomp[is.na(mergeT)]
tensors$merge[[method]] = mergeT
print('..predicted tensor')
predT = tcomp
predT[!is.na(tensors$cv[[method]])] = NA
tensors$pred[[method]] = predT
stopifnot(NumSigs(tensors$pred[[method]]) + NumSigs(tensors$cv[[method]]) == NumSigs(tcomp))
rm(predT, tcomp, mergeT)
}
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_5B_gene_cor_bargraphs.R')
numSigs = NumSigs(tensors$meas, 'cell')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_5B_gene_cor_bargraphs.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/figures/FIGURE_7B_tsize_results.R')
getwd()
rm(list=ls())
testAll = TRUE
source('R/init.R')
load(DataDir('tensors/T_test.RData'))
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/test/test_DataProc.R')
source('R/init.R')
file = DataFile('tensors/cmap.mat')
stopifnot(file.exists(file))
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/test/test_DataProc.R')
source('R/init.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/test/test_DataProc.R')
TestNumSigs()
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/test/test_DataProc.R')
TestNumSigs()
source('R/init.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/test/test_DataProc.R')
source('R/init.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/src/DataProc.R')
source('R/init.R')
source('R/init.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/test/test_DefineTensor.R')
source('R/init.R')
source('R/init.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/src/DefineTensor.R')
source('R/init.R')
source('~/Dropbox (Dudley Lab)/LINCS/submission/dgc_predict/R/src/DefineTensor.R')
source('R/init.R')
matlab = StartMatlab()
matlab = StartMatlab()
